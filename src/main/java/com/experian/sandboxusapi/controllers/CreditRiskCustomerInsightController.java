/*
 * CommercialCreditAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.experian.sandboxusapi.controllers;

import com.experian.sandboxusapi.ApiHelper;
import com.experian.sandboxusapi.Server;
import com.experian.sandboxusapi.exceptions.ApiException;
import com.experian.sandboxusapi.exceptions.ErrorResponseException;
import com.experian.sandboxusapi.http.request.HttpMethod;
import com.experian.sandboxusapi.models.BusinessOwnerDetailsResponse;
import com.experian.sandboxusapi.models.BusinessOwnerSearchReq;
import com.experian.sandboxusapi.models.BusinessTargeterResponse;
import com.experian.sandboxusapi.models.DirectorData;
import com.experian.sandboxusapi.models.DirectorTargeterResponse;
import com.experian.sandboxusapi.models.LtdCompanyData;
import com.experian.sandboxusapi.models.NonLtdBusinessData;
import com.fasterxml.jackson.core.JsonProcessingException;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class CreditRiskCustomerInsightController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public CreditRiskCustomerInsightController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * &lt;div&gt; Search Experian's UK Business database to return either the best matching business or a
     * list of businesses to choose from. You can then use a returned identifier to request
     * additional business information from many of Experian's Business Information APIs. &lt;br/&gt;&lt;br/&gt;
     * Searches can be made using: &lt;ul&gt; &lt;li&gt;the business name only&lt;/li&gt; &lt;li&gt;the business
     * postcode&lt;/li&gt; &lt;li&gt;the business identifiers (registration number or Experian non limited
     * key)&lt;/li&gt; &lt;li&gt;additional filters to qualify the search scope (registered/non registered,
     * dissolved businesses)&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; Sample searches against name=TEST will work in the
     * Sandbox. &lt;/div&gt;.
     * @param  name  Optional parameter: Business name to be used in the search
     * @param  postcode  Optional parameter: Postcode of location to be used in the search
     * @param  town  Optional parameter: Town location to be used in the search
     * @param  phonenumber  Optional parameter: Telephone number to be used in the search
     * @param  businessref  Optional parameter: Business reference (registered number or NonLimited
     *         URN) to be used in the search. Sample 99999999 or UI88888888.
     * @param  searchcorporates  Optional parameter: Indicator showing whether to include limited
     *         businesses in the search (true = Include, false = Exclude)
     * @param  excludedissolved  Optional parameter: Indicator showing whether to include dissolved
     *         limited businesses in the search (true = Include, false = Exclude)
     * @param  searchnoncorps  Optional parameter: Indicator showing whether to include non-limited
     *         businesses in the search (true = Include, false = Exclude)
     * @return    Returns the BusinessTargeterResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public BusinessTargeterResponse businessSearch(
            final String name,
            final String postcode,
            final String town,
            final String phonenumber,
            final String businessref,
            final Boolean searchcorporates,
            final Boolean excludedissolved,
            final Boolean searchnoncorps) throws ApiException, IOException {
        return prepareBusinessSearchRequest(name, postcode, town, phonenumber, businessref,
                searchcorporates, excludedissolved, searchnoncorps).execute();
    }

    /**
     * &lt;div&gt; Search Experian's UK Business database to return either the best matching business or a
     * list of businesses to choose from. You can then use a returned identifier to request
     * additional business information from many of Experian's Business Information APIs. &lt;br/&gt;&lt;br/&gt;
     * Searches can be made using: &lt;ul&gt; &lt;li&gt;the business name only&lt;/li&gt; &lt;li&gt;the business
     * postcode&lt;/li&gt; &lt;li&gt;the business identifiers (registration number or Experian non limited
     * key)&lt;/li&gt; &lt;li&gt;additional filters to qualify the search scope (registered/non registered,
     * dissolved businesses)&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; Sample searches against name=TEST will work in the
     * Sandbox. &lt;/div&gt;.
     * @param  name  Optional parameter: Business name to be used in the search
     * @param  postcode  Optional parameter: Postcode of location to be used in the search
     * @param  town  Optional parameter: Town location to be used in the search
     * @param  phonenumber  Optional parameter: Telephone number to be used in the search
     * @param  businessref  Optional parameter: Business reference (registered number or NonLimited
     *         URN) to be used in the search. Sample 99999999 or UI88888888.
     * @param  searchcorporates  Optional parameter: Indicator showing whether to include limited
     *         businesses in the search (true = Include, false = Exclude)
     * @param  excludedissolved  Optional parameter: Indicator showing whether to include dissolved
     *         limited businesses in the search (true = Include, false = Exclude)
     * @param  searchnoncorps  Optional parameter: Indicator showing whether to include non-limited
     *         businesses in the search (true = Include, false = Exclude)
     * @return    Returns the BusinessTargeterResponse response from the API call
     */
    public CompletableFuture<BusinessTargeterResponse> businessSearchAsync(
            final String name,
            final String postcode,
            final String town,
            final String phonenumber,
            final String businessref,
            final Boolean searchcorporates,
            final Boolean excludedissolved,
            final Boolean searchnoncorps) {
        try { 
            return prepareBusinessSearchRequest(name, postcode, town, phonenumber, businessref,
            searchcorporates, excludedissolved, searchnoncorps).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for businessSearch.
     */
    private ApiCall<BusinessTargeterResponse, ApiException> prepareBusinessSearchRequest(
            final String name,
            final String postcode,
            final String town,
            final String phonenumber,
            final String businessref,
            final Boolean searchcorporates,
            final Boolean excludedissolved,
            final Boolean searchnoncorps) throws IOException {
        return new ApiCall.Builder<BusinessTargeterResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v2/businesstargeter")
                        .queryParam(param -> param.key("name")
                                .value((name != null) ? name : "TEST").isRequired(false))
                        .queryParam(param -> param.key("postcode")
                                .value(postcode).isRequired(false))
                        .queryParam(param -> param.key("town")
                                .value(town).isRequired(false))
                        .queryParam(param -> param.key("phonenumber")
                                .value(phonenumber).isRequired(false))
                        .queryParam(param -> param.key("businessref")
                                .value(businessref).isRequired(false))
                        .queryParam(param -> param.key("searchcorporates")
                                .value((searchcorporates != null) ? searchcorporates : true).isRequired(false))
                        .queryParam(param -> param.key("excludedissolved")
                                .value((excludedissolved != null) ? excludedissolved : true).isRequired(false))
                        .queryParam(param -> param.key("searchnoncorps")
                                .value((searchnoncorps != null) ? searchnoncorps : false).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, BusinessTargeterResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request. Incorrect verb or path provided",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.create("Unauthorized access. Invalid or Expired Token, or product not enabled against the account",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.create("Not Acceptable. Invalid headers provided.",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Unprocessable Entity. Incorrect parameters provided",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal server error",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns detailed information on UK limited companies, including corporate structure,
     * management info, shareholders, financials, Commercial Delphi credit scores and history, CCJs,
     * mortgages, legal notices, Cifas fraud data and business credit history (CAIS).&lt;br/&gt; Sample
     * searches using RegNumber=99999999 will work in the Sandbox.
     * @param  regNumber  Required parameter: Company registration number; Sample RegNumber is
     *         99999999.
     * @return    Returns the LtdCompanyData response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public LtdCompanyData registeredCompanyCredit(
            final String regNumber) throws ApiException, IOException {
        return prepareRegisteredCompanyCreditRequest(regNumber).execute();
    }

    /**
     * Returns detailed information on UK limited companies, including corporate structure,
     * management info, shareholders, financials, Commercial Delphi credit scores and history, CCJs,
     * mortgages, legal notices, Cifas fraud data and business credit history (CAIS).&lt;br/&gt; Sample
     * searches using RegNumber=99999999 will work in the Sandbox.
     * @param  regNumber  Required parameter: Company registration number; Sample RegNumber is
     *         99999999.
     * @return    Returns the LtdCompanyData response from the API call
     */
    public CompletableFuture<LtdCompanyData> registeredCompanyCreditAsync(
            final String regNumber) {
        try { 
            return prepareRegisteredCompanyCreditRequest(regNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for registeredCompanyCredit.
     */
    private ApiCall<LtdCompanyData, ApiException> prepareRegisteredCompanyCreditRequest(
            final String regNumber) throws IOException {
        return new ApiCall.Builder<LtdCompanyData, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v2/registeredcompanycredit/{RegNumber}")
                        .templateParam(param -> param.key("RegNumber").value(regNumber)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, LtdCompanyData.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Unauthorized access. Invalid or Expired Token, or product not enabled against the account",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Company not found",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.create("Not Acceptable. Invalid headers provided.",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal server error",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns detailed information on UK non-limited businesses, including Commercial Delphi credit
     * scores and history, commercial credit history (CAIS), payment performance, Cifas fraud data,
     * CCJs and bankruptcies.&lt;br/&gt; Sample searches using NonLimitedKey=UI88888888 will work in the
     * Sandbox.
     * @param  nonLimitedKey  Required parameter: Experian Non limited key for the non-registered
     *         company. Sample non limited key is UI88888888.
     * @return    Returns the NonLtdBusinessData response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public NonLtdBusinessData nonRegisteredCompanyCredit(
            final String nonLimitedKey) throws ApiException, IOException {
        return prepareNonRegisteredCompanyCreditRequest(nonLimitedKey).execute();
    }

    /**
     * Returns detailed information on UK non-limited businesses, including Commercial Delphi credit
     * scores and history, commercial credit history (CAIS), payment performance, Cifas fraud data,
     * CCJs and bankruptcies.&lt;br/&gt; Sample searches using NonLimitedKey=UI88888888 will work in the
     * Sandbox.
     * @param  nonLimitedKey  Required parameter: Experian Non limited key for the non-registered
     *         company. Sample non limited key is UI88888888.
     * @return    Returns the NonLtdBusinessData response from the API call
     */
    public CompletableFuture<NonLtdBusinessData> nonRegisteredCompanyCreditAsync(
            final String nonLimitedKey) {
        try { 
            return prepareNonRegisteredCompanyCreditRequest(nonLimitedKey).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for nonRegisteredCompanyCredit.
     */
    private ApiCall<NonLtdBusinessData, ApiException> prepareNonRegisteredCompanyCreditRequest(
            final String nonLimitedKey) throws IOException {
        return new ApiCall.Builder<NonLtdBusinessData, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v2/nonregisteredbusinesscredit/{NonLimitedKey}")
                        .templateParam(param -> param.key("NonLimitedKey").value(nonLimitedKey)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, NonLtdBusinessData.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Unauthorized access. Invalid or Expired Token, or product not enabled against the account",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Company not found",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.create("Not Acceptable. Invalid headers provided.",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal server error",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * &lt;div&gt; Search Experian's UK Business database to return a list of Directors and/or
     * Secretaries. Each matching entry provides an identifier which can be used to access
     * additional information about the director via other endpoints such as Director Details.
     * &lt;br/&gt;&lt;br/&gt; Searches can be made using: &lt;li&gt;forename, middlenames and surname&lt;/li&gt; &lt;li&gt;service
     * address postcode&lt;/li&gt; &lt;li&gt;flags qualifying the scope of the search
     * (directors/secretaries).&lt;/li&gt; &lt;/div&gt; &lt;br/&gt; Sample searches using forename=John and
     * surname=Smith will return data in the Sandbox.
     * @param  title  Optional parameter: Director's title (Lord, Dame, etc.) returned from the
     *         Director search
     * @param  forename  Optional parameter: Director's forename returned from the Director search
     * @param  middlenames  Optional parameter: Director's middle names returned from the Director
     *         search
     * @param  surname  Optional parameter: Director's surname returned from the Director search
     * @param  suffix  Optional parameter: Director's name suffix (Jnr. etc.) returned from the
     *         Director search
     * @param  dateofbirth  Optional parameter: Director's Date of Birth
     * @param  flat  Optional parameter: Director's address flat
     * @param  housename  Optional parameter: Director's address house name
     * @param  housenumber  Optional parameter: Director's address house number
     * @param  street  Optional parameter: Director's service address street
     * @param  district  Optional parameter: Director's address district
     * @param  county  Optional parameter: Director's address county
     * @param  postcode  Optional parameter: Director's address postcode
     * @param  town  Optional parameter: Director's address town
     * @param  directorsflag  Optional parameter: Indicator showing whether to include Directors in
     *         the search (true = Include, false = Exclude)
     * @param  secretariesflag  Optional parameter: Indicator showing whether to include Secretaries
     *         in the search (true = Include, false = Exclude)
     * @return    Returns the DirectorTargeterResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DirectorTargeterResponse directorSearch(
            final String title,
            final String forename,
            final String middlenames,
            final String surname,
            final String suffix,
            final String dateofbirth,
            final String flat,
            final String housename,
            final String housenumber,
            final String street,
            final String district,
            final String county,
            final String postcode,
            final String town,
            final Boolean directorsflag,
            final Boolean secretariesflag) throws ApiException, IOException {
        return prepareDirectorSearchRequest(title, forename, middlenames, surname, suffix,
                dateofbirth, flat, housename, housenumber, street, district, county, postcode, town,
                directorsflag, secretariesflag).execute();
    }

    /**
     * &lt;div&gt; Search Experian's UK Business database to return a list of Directors and/or
     * Secretaries. Each matching entry provides an identifier which can be used to access
     * additional information about the director via other endpoints such as Director Details.
     * &lt;br/&gt;&lt;br/&gt; Searches can be made using: &lt;li&gt;forename, middlenames and surname&lt;/li&gt; &lt;li&gt;service
     * address postcode&lt;/li&gt; &lt;li&gt;flags qualifying the scope of the search
     * (directors/secretaries).&lt;/li&gt; &lt;/div&gt; &lt;br/&gt; Sample searches using forename=John and
     * surname=Smith will return data in the Sandbox.
     * @param  title  Optional parameter: Director's title (Lord, Dame, etc.) returned from the
     *         Director search
     * @param  forename  Optional parameter: Director's forename returned from the Director search
     * @param  middlenames  Optional parameter: Director's middle names returned from the Director
     *         search
     * @param  surname  Optional parameter: Director's surname returned from the Director search
     * @param  suffix  Optional parameter: Director's name suffix (Jnr. etc.) returned from the
     *         Director search
     * @param  dateofbirth  Optional parameter: Director's Date of Birth
     * @param  flat  Optional parameter: Director's address flat
     * @param  housename  Optional parameter: Director's address house name
     * @param  housenumber  Optional parameter: Director's address house number
     * @param  street  Optional parameter: Director's service address street
     * @param  district  Optional parameter: Director's address district
     * @param  county  Optional parameter: Director's address county
     * @param  postcode  Optional parameter: Director's address postcode
     * @param  town  Optional parameter: Director's address town
     * @param  directorsflag  Optional parameter: Indicator showing whether to include Directors in
     *         the search (true = Include, false = Exclude)
     * @param  secretariesflag  Optional parameter: Indicator showing whether to include Secretaries
     *         in the search (true = Include, false = Exclude)
     * @return    Returns the DirectorTargeterResponse response from the API call
     */
    public CompletableFuture<DirectorTargeterResponse> directorSearchAsync(
            final String title,
            final String forename,
            final String middlenames,
            final String surname,
            final String suffix,
            final String dateofbirth,
            final String flat,
            final String housename,
            final String housenumber,
            final String street,
            final String district,
            final String county,
            final String postcode,
            final String town,
            final Boolean directorsflag,
            final Boolean secretariesflag) {
        try { 
            return prepareDirectorSearchRequest(title, forename, middlenames, surname, suffix, dateofbirth,
            flat, housename, housenumber, street, district, county, postcode, town, directorsflag,
            secretariesflag).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for directorSearch.
     */
    private ApiCall<DirectorTargeterResponse, ApiException> prepareDirectorSearchRequest(
            final String title,
            final String forename,
            final String middlenames,
            final String surname,
            final String suffix,
            final String dateofbirth,
            final String flat,
            final String housename,
            final String housenumber,
            final String street,
            final String district,
            final String county,
            final String postcode,
            final String town,
            final Boolean directorsflag,
            final Boolean secretariesflag) throws IOException {
        return new ApiCall.Builder<DirectorTargeterResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v2/directortargeter")
                        .queryParam(param -> param.key("title")
                                .value(title).isRequired(false))
                        .queryParam(param -> param.key("forename")
                                .value((forename != null) ? forename : "John").isRequired(false))
                        .queryParam(param -> param.key("middlenames")
                                .value((middlenames != null) ? middlenames : "William").isRequired(false))
                        .queryParam(param -> param.key("surname")
                                .value((surname != null) ? surname : "Smith").isRequired(false))
                        .queryParam(param -> param.key("suffix")
                                .value(suffix).isRequired(false))
                        .queryParam(param -> param.key("dateofbirth")
                                .value(dateofbirth).isRequired(false))
                        .queryParam(param -> param.key("flat")
                                .value(flat).isRequired(false))
                        .queryParam(param -> param.key("housename")
                                .value(housename).isRequired(false))
                        .queryParam(param -> param.key("housenumber")
                                .value(housenumber).isRequired(false))
                        .queryParam(param -> param.key("street")
                                .value(street).isRequired(false))
                        .queryParam(param -> param.key("district")
                                .value(district).isRequired(false))
                        .queryParam(param -> param.key("county")
                                .value(county).isRequired(false))
                        .queryParam(param -> param.key("postcode")
                                .value(postcode).isRequired(false))
                        .queryParam(param -> param.key("town")
                                .value(town).isRequired(false))
                        .queryParam(param -> param.key("directorsflag")
                                .value((directorsflag != null) ? directorsflag : true).isRequired(false))
                        .queryParam(param -> param.key("secretariesflag")
                                .value((secretariesflag != null) ? secretariesflag : false).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, DirectorTargeterResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request. Incorrect verb or path provided",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.create("Unauthorized access. Invalid or Expired Token, or product not enabled against the account",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.create("Not Acceptable. Invalid headers provided.",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Unprocessable Entity. Incorrect parameters provided",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal server error",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns detailed information about a Director of UK Limited company, including other
     * Directorships, disqualifications, convictions and Cifas fraud data. &lt;br/&gt;&lt;br/&gt; Sample
     * searches against DirectorNumber=D99999999 will return data in the Sandbox.
     * @param  directorNumber  Required parameter: Director unique reference number; Sample
     *         DirectorNumber D99999999.
     * @return    Returns the DirectorData response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DirectorData directorsDetails(
            final String directorNumber) throws ApiException, IOException {
        return prepareDirectorsDetailsRequest(directorNumber).execute();
    }

    /**
     * Returns detailed information about a Director of UK Limited company, including other
     * Directorships, disqualifications, convictions and Cifas fraud data. &lt;br/&gt;&lt;br/&gt; Sample
     * searches against DirectorNumber=D99999999 will return data in the Sandbox.
     * @param  directorNumber  Required parameter: Director unique reference number; Sample
     *         DirectorNumber D99999999.
     * @return    Returns the DirectorData response from the API call
     */
    public CompletableFuture<DirectorData> directorsDetailsAsync(
            final String directorNumber) {
        try { 
            return prepareDirectorsDetailsRequest(directorNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for directorsDetails.
     */
    private ApiCall<DirectorData, ApiException> prepareDirectorsDetailsRequest(
            final String directorNumber) throws IOException {
        return new ApiCall.Builder<DirectorData, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v2/directordetails/{DirectorNumber}")
                        .templateParam(param -> param.key("DirectorNumber").value(directorNumber)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, DirectorData.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Unauthorized access. Invalid or Expired Token, or product not enabled against the account",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Director not found",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.create("Not Acceptable. Invalid headers provided.",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal server error",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns detailed information about owners of non-registered UK businesses, including public
     * information, voters roll, associations, Cifas fraud data and credit history (CAIS). This
     * enables you to perform a credit assessment, based on up to 3 business proprietors, when
     * you're unable to locate a business.
     * @param  body  Required parameter: Example:
     * @return    Returns the BusinessOwnerDetailsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public BusinessOwnerDetailsResponse businessOwners(
            final BusinessOwnerSearchReq body) throws ApiException, IOException {
        return prepareBusinessOwnersRequest(body).execute();
    }

    /**
     * Returns detailed information about owners of non-registered UK businesses, including public
     * information, voters roll, associations, Cifas fraud data and credit history (CAIS). This
     * enables you to perform a credit assessment, based on up to 3 business proprietors, when
     * you're unable to locate a business.
     * @param  body  Required parameter: Example:
     * @return    Returns the BusinessOwnerDetailsResponse response from the API call
     */
    public CompletableFuture<BusinessOwnerDetailsResponse> businessOwnersAsync(
            final BusinessOwnerSearchReq body) {
        try { 
            return prepareBusinessOwnersRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for businessOwners.
     */
    private ApiCall<BusinessOwnerDetailsResponse, ApiException> prepareBusinessOwnersRequest(
            final BusinessOwnerSearchReq body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<BusinessOwnerDetailsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v2/businessownerdetails")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, BusinessOwnerDetailsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Unauthorized access. Invalid or Expired Token, or product not enabled against the account",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Business Owner not found",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.create("Not Acceptable. Invalid headers provided.",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Unprocessable Entity. Incorrect parameters provided",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal server error",
                                (reason, context) -> new ErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}